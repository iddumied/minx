Much simpler:

special registers:
------------------
Registers 0x00 to 0x0F are special, they are not useable for program data.

- 0x0000	Programm-ptr, is zero at init and 0xFFFF at end of programm
- 0x0001	(unused)
- 0x0002	akku-register
- 0x0003	status-register 
	Bit	|	use 
	----+-------
	0	|	overflow 
	1-7	|	not used yet
- 0x0004	overflow value 
- 0x0005-0x000F (unused yet)

All other registers are available (if addressable with 64 bit)

stack 
-----
- infinite size (only limited by your system)
- used for both function calls and pushing values

codes
-----

A opcode is 16 Bit, registers, values and adresses are 64 bit

'Register'	stands for 64 Bit register address 
'Value'		stands for 64 Bit value
'Adress'	stands for 64 Bit code address

code	|	Short expl.	|	arguments				|	Expl.
--------+---------------+---------------------------+---------------------------
0x00	|	NOP			|	none					|
0x01	|	RET			|	none					| Jump to $(stack pop)

0x02	|	MOV			|	Register, Register		|
0x03	|	MOVI		|	Register, Value			|

0x04	|	NOT			|	Register				| result in akku
0x05	|	NOTR		|	Register				| result in register

0x06	|	AND			|	Register, Register		| result in akku
0x07	|	ANDI		|	Register, Value			| result in akku
0x08	|	ANDR		|	Register, Register		| result in register 
0x09	|	ANDIR		|	Register, Value			| result in register

0x0A	|	OR			|	Register, Register		| result in akku 
0x0B	|	ORI			|	Register, Value			| result in akku 
0x0C	|	ORR			|	Register, Register		| result in register 
0x0D	|	ORIR		|	Register, Value			| result in register

0x0E	|	DEC			|	Register				| result in register 
0x0F	|	INC			|	Register				| result in register 

0x10	|	LSH			|	Register				| result in register 
0x11	|	RSH			|	Register				| result in register 

0x20	|	PUSH		|	Register				| push register to stack
0x21	|	POP			|	Register				| pop from stack into register
0x22	|	DROP		|	none					| pop from stack and drop

0x30	|	ADD			|	Register, Register		| result in akku 
0x31	|	ADDI		|	Register, Value			| result in akku 
0x32	|	ADDR		|	Register, Register		| result in register 
0x33	|	ADDIR		|	Register, Value			| result in register

0x40	|	JMP			|	Adress					| jump to address (number of byte)
0x41	|	JMPIZ		|	Register, Adress		| jump if register is zero
0x42	|	JMPNZ		|	Register, Adress		| jump if register is not zero
0x43	|	IFZJMP		|	Adress, Adress			| if akku is zero jump, else jump

Special: (no support yet, later versions will support them)

0x60	|	LNREG		|	Register				| load value of next register into akku
0x61	|	LPREG		|	Register				| load value of prev register into akku

Not supported yet:
-----------------
- Pointers to registers

0x70	|	GETP		|	Register				| Write current program pointer to register and next one
0x71	|	GETPA		|	Adress, Register		| Write adress to register and next register
0x72	|	SETP		|	Register				| Set current programm pointer to address(register, next register)

