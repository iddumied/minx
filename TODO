TODO:

4) overflow value is not set into overflow-value-register

5) define a op code for defining op-codes.
	Something like this:

	DEF(opc, funcloc)

	where opc is the opcode to define (or redefine). It will be automatically
	masked for 16 bit.
	The funcloc is a pointer to a function which is defined somewhere in the
	binary. This function is read into the VPU and stored there. If the op code
	which was defined is used, the VPU executes the stored procedure.

	There should be some status registers reserved for statuses about the call.
		-	was a override
		-	worked/error

5.1)define a op code ISDEV(reg, opc) for getting if a opcode is defined, result
	in 'reg'

9)	File reader should read the file as linked list, with automatically removing 
	"old" parts of the file from memory to keep memuse smart.

12) Implement heap:
		- opcodes: 
			ALLOC(size in byte) -> ptr/addr of first byte in akku or 0x00 on error
			RESIZE(addr, size in byte)
			FREE(addr)
			PUT(addr, register-ptr, value-size in byte)
			READ(addr, register-ptr, size in byte)

		PUT and READ require a ptr to a register and a size parameter. If the
		size is more than one register (8 byte), next register will be used to
		put or read!

		- statuses:
			- statusflags for all opcodes for errors 
			- counter for how much register were used to PUT from
			- counter for how much register were used to READ into 

	Manage the heaps in a linked list, each entry has its size, which is used to
	calculate the address of the next entry.

14) Create a plugin-system
	opcodes:
		LOADMODULE(memory) 
			passed memory should be the path to the .so file!
			This opcodes should write a uniq module identifier into akku.
			
		MODCALL(moduleID, opcode, memory)
			the passed memory represents the parameters for the opcode. The
			opcodes in the modules have to read the memory themself.

		UNDLOADMODULE(moduleID)
			remove module from runtime. The module ID will not be reused!

	In the first implementation, the VPU will not ensure, the moduleID is
	used. If the binary does load a module and override the akku in the next
	step, the module is loaded and cannot be unloaded!
	In the next step of the implementation, the VPU will ensure, the akku is
	locked or it will fail if the binary wants to override a not-copied
	moduleID, don't know yet!

	If the binary wants to access a module which is not loaded or which is
	unloaded already, the VPU will fail and exit.

	A module has to implement several functions:
		- a function for loading the module
		- a function where the arguments of the minx call will be passed
		- a function for calling the module, which gets a opcode and a HeapNode,
		  this function should return the HeapNode!
		- a function for getting data for the akku, which is called directly
		  after the module-call function
		- a function for unloading
		- a function for force-shutdown of the VM
		- a function for shutdown without unloading

15) Clean up the opcodes-protocol and release it as v1.0.0 to guarantee no more
	changes of its core functionality.

16) Add Disassembler 
